{
	"Mod": {
		"name": "Skynet mod",
		"author": "SlitheringHorror",
		"description": "Mon, 20 Apr 2020 15:33:49 GMT",
		"titleLeft": "Skynet ",
		"titleRight": "Mod!",
		"subtitleLeft": "Boosts bots' reaction times to be nigh-instanteneous",
		"subtitleRight": "and makes them lead targets"
	},
	"Matchmaking": {
		"MaxBots": 1
	},
	"World": {
		"BotName": "MurderBot"
	},
	"Choices": {
		"Keys": [
			{
				"btn": "a",
				"barSize": 0.75,
				"wheelSize": 0.5
			},
			{
				"btn": "p",
				"barSize": 0.1,
				"wheelSize": 0.1
			},
			{
				"btn": "q",
				"barSize": 1,
				"wheelSize": 1
			},
			{
				"btn": "w",
				"barSize": 1,
				"wheelSize": 0.75
			},
			{
				"btn": "e",
				"barSize": 1,
				"wheelSize": 0.75
			},
			{
				"btn": "r",
				"barSize": 1,
				"wheelSize": 0.75
			},
			null,
			{
				"btn": "f",
				"barSize": 0.75,
				"wheelSize": 0.5
			}
		],
		"Options": {
			"p": [
				[
					"point"
				]
			]
		}
	},
	"Spells": {
		"point": {
			"id": "point",
			"name": "Point",
			"description": "For testing. Mark a point in space. No effect. Flies like a very fast horcrux.",
			"action": "projectile",
			"sound": "horcrux",
			"color": "#22ee88",
			"icon": "cometSpark",
			"maxAngleDiffInRevs": 0.01,
			"cooldown": 1,
			"throttle": true,
			"projectile": {
				"density": 0.000001,
				"restitution": 0,
				"radius": 0.0035,
				"speed": 1,
				"maxTicks": 30,
				"minTicks": 1,
				"damage": 0,
				"lifeSteal": 0,
				"collideWith": 29,
				"expireOn": 5,
				"destructible": {},
				"conveyable": false,
				"bumpable": false,
				"shieldTakesOwnership": false,
				"projectileBuffs": [],
				"renderers": [
					{
						"type": "projectile",
						"ticks": 10,
						"noPartialRadius": true
					}
				],
				"behaviours": [
					{
						"type": "homing",
						"targetType": "cursor",
						"trigger": {
							"afterTicks": 60,
							"atCursor": true
						},
						"newSpeed": 0,
						"redirect": true
					}
				],
				"sound": "horcrux",
				"color": "#22ee88"
			}
		}
	},
	"Code": "var center = { x: 0.5, y: 0.5 };\n\nvar CloseEnoughDistance = 0.05;\nvar CloseEnoughRadians = 0.03 * Math.PI;\nvar MissRadius = 0;\nvar DodgeRadius = 0.15;\nvar SpellCastIntervalMilliseconds = 500;\nvar SpellCastJitterMilliseconds = 300;\n\nvar TicksPerSecond = 60;\n\nvar HardReactionMilliseconds = 1;\nvar EasyReactionMilliseconds = 1;\nvar ReactionMillisecondsLookup = { // Change the reaction time on certain spells\n    retarget: 1,\n};\n\nvar alreadyChosenSpells = false;\nvar nextSpell = 0;\n\n// See ai.contracts.ts:\n// input is InputContract - contains information about the current state of the world\n// output is OutputContract - an action you want to take in response to the world \n\n//parameters for the bot\nvar enableTargetLeading = true;\nvar RepeaterCastIntervalMilliseconds = 50;\nvar enableObstacleRaytracing = false;//not implemented\nvar positionTrackingTicks = 120; //how many to track, including the current one. At least 2.\nvar intersectionOptimizationSteps = 5; //from aim: how many times to refine the guess for the intersection point.\nvar movementLocationChangeTicks = 30; //from move: how often to update the location to move to\nconst PREDICT_TESTING = false; //if true, BOTS WILL NOT FIGHT and only show their targeting\nvar minDodgeDistance = 0.03; //The bot will dodge projectiles it expects to pass within this distance of its current position. acolyte radius is 0.0125\nvar minDodgeTime = 0.75; //The bot won't dodge projectiles which have more than that long to fly until closest approach.\nvar maxDeflectTime = 0.15;//The bot will deflect projectiles which are that long away from hitting them.\nvar DEBUG_NO_MOVE = false;//disables `move`\n//memory vars\nvar trackedPositions = {}; //dictionary of arrays(of length up to positionTrackingTicks) of positions\nvar lastMoveTick = -1000;\nvar lastMovePosition = undefined;\n\nfunction aim(target, spell, caster) {\n  const DEBUG_AIM = false;\n  // Gets target, spell, and caster, outputs the position for caster to aim at to hit the target with the spell.\n  if(!enableTargetLeading){\n    return target.pos;\n  }\n  const AIM_EXCLUDED_SPELLS = ['dualSaber','halo','mines'];\n  if(AIM_EXCLUDED_SPELLS.indexOf(spell.id)>=0){//if in list\n    return target.pos;\n  }\n  /*old tracking code\n  const HEROSPEED = 0.12 //not sure I can get it directly\n  \n  var curPos = target.pos; //vector\n  var targetForcedVelocity = target.velocity; //vector - this is only enforced velocity from knockback\n  var targetMoveVelocity = vectorMultiply(vectorFromAngle(target.heading),HEROSPEED);\n  var targetVelocity = vectorPlus(targetForcedVelocity,targetMoveVelocity);\n  var range = vectorDistance(caster.pos, curPos);\n  var time1 = range/spell.projectile.speed; // naive guess at a time-to-hit, in seconds\n  var deltaX = vectorMultiply(targetVelocity,time1); //leading distance\n  */\n  \n  //new code: prediction based on old positions\n  //the current position should already be in trackedPositions\n  var curPos = target.pos;\n  var tracker = trackedPositions[target.id];\n  !DEBUG_AIM || console.log(tracker);\n  if(tracker === undefined||tracker.length <= 1){\n    return curPos;//TODO: better handling cases when the target has no tracked poses for some reason.\n  }\n  /*//most naive way: velocity = (<newest pos>-<oldest pos>)/(positionTrackingTicks-1)\n  var estimatedVelocity = vectorMultiply(vectorDiff(tracker[tracker.length-1],tracker[0]),1/(positionTrackingTicks-1));//this is speed per tick*/\n  //less naive way: linear approximation\n  var estimatedVelocity = linearApproximation(tracker);\n  //console.log(\"estimatedVelocity:\"+myVectorToString(estimatedVelocity));\n  var range = vectorDistance(caster.pos, curPos);\n  var time1 = range/spell.projectile.speed; // first naive guess, in seconds\n  if(spell.chargeTicks>0){time1+=spell.chargeTicks/TicksPerSecond;}//for spells like repulsor\n  var deltaX = vectorMultiply(estimatedVelocity,time1*TicksPerSecond);//converting from per tick to per second\n  var aimPos = vectorPlus(curPos, deltaX);\n  for(let i=1;i<intersectionOptimizationSteps;i++){\n    //intersection refinement\n    //console.log(\"i=\"+i+\";time1=\"+time1);\n    var range = vectorDistance(caster.pos, aimPos);//to the aiming position this time\n    var time1 = range/spell.projectile.speed; // refined guess of the time\n    if(spell.chargeTicks>0){time1+=spell.chargeTicks/TicksPerSecond;}//for spells like repulsor\n    var deltaX = vectorMultiply(estimatedVelocity,time1*TicksPerSecond);//converting from per tick to per second\n    var aimPos = vectorPlus(curPos, deltaX);\n  }\n  !DEBUG_AIM || console.log(\"spellSpeed:\"+spell.projectile.speed+\";estimatedVelocity:\"+myVectorToString(estimatedVelocity));\n  return aimPos;\n}\nfunction linearApproximation(posArray){\n  //gets an array of vectors, assumed to be all with a separation of 1 tick, outputs incline of least-squares approximation\n  let valNum = posArray.length;\n  let X = [];\n  let Y = [];\n  for(let i=0;i<valNum;i++){\n    X.push(posArray[i].x);\n    Y.push(posArray[i].y);\n  }\n  let T = myRange(0,valNum);\n  let aX = ODLR(T,X).a;\n  let aY = ODLR(T,Y).a;\n  return {x:aX,y:aY};//b we don't care about\n}\nfunction ODLR(X,Y){\n  //one-dimensional linear regression\n  //outputs parameters of approximation `ax+b` of points in the input\n  //X,Y - arrays of numbers, same length\n  let n = X.length;\n  let XY = myArrayMultiply(X,Y);\n  let XX = myArrayMultiply(X,X);\n  let YY = myArrayMultiply(Y,Y);\n  let XSum=0,YSum=0,XXSum=0,XYSum=0,YYSum=0;\n  for(let i=0;i<n;i++){\n    XSum+=X[i];YSum+=Y[i];XXSum+=XX[i];XYSum+=XY[i];YYSum+=YY[i];\n  }\n  let a = (n*XYSum-XSum*YSum)/(n*XXSum-XSum*XSum);\n  let b = (XSum*XYSum-XXSum*YSum)/(XSum*XSum-n*XXSum);\n  return {a:a,b:b};//I sure hope I didn't make a mistake here, lol\n}\nfunction myRange(a,b){\n  //like in python - array from a inclusive to b exclusive\n  let res = [];\n  for(let i = a; i < b; i++){\n    res.push(i);\n  }\n  return res;\n}\nfunction myArrayMultiply(a,b){\n  //array elementwise multiplication\n  //can work on 2-vec\n  if(a.length!=b.length||typeof a != typeof b){\n    console.log(\"Trying to multiply arrays of different sizes/types\");\n    return undefined;//TODO: error out in a better way.\n  }\n  let res = [];\n  if(a.length>0 && a[0].x!==undefined){\n  //assume vector arrays\n  for(let i = 0; i<a.length;i++){\n      res.push({x:a[i].x*b[i].x,y:a[i].y*b[i].y});\n    }\n  }\n  else{\n    for(let i = 0; i<a.length;i++){\n      res.push(a[i]*b[i]);\n    }\n  }\n  return res;\n}\nfunction myArraySum(a){\n  if(a.length==0){return 0;}\n  //sums arrays, including vector ones\n  if(a[0].x!==undefined){\n    //assuming vector array\n    let sumX=0;\n    let sumY=0;\n    for(let i=0;i<a.length;i++){\n      sumX+=a[i].x;\n      sumY+=a[i].y;\n    }\n    return {x:sumX,y:sumY};\n  }\n  else{\n    let sum=0\n    for(let i=0;i<a.length;i++){\n      sum+=a[i];\n    }\n    return sum;\n  }\n}\nfunction myVectorToString(vector){\n  return \"(x:\"+vector.x+\";y:\"+vector.y+\")\"\n}\nfunction doesLineIntersectObstacles(pos1, pos2, obstacles, lookup){\n  //lookup is ObstacleTemplateLookup\n  for (var obstacle in obstacles) {\n    var C = obstacle.pos;\n    var closest = findClosestDistanceToPoint(pos, pos2, C);\n    var obstacleTemplate = lookup[obstacle.type];\n    //if(closest<) \n    //oh, I can't get an obstacle's radius...\n    return false;\n  }\n}\n\nfunction findClosestDistanceToPoint(pos1, pos2, otherPos){\n  //return closest distance to otherPos among points on the line segment from pos1 to pos2.\n  var AB = vectorDiff(pos2, pos1);\n  var AC = vectorDiff(otherPos, pos1);\n  var BC = vectorDiff(otherPos, pos2);\n  var AB_BC = vectorDot(AB,BC);\n  var AB_AC = vectorDot(AB,AC);\n  var result = 0;\n  if (AB_BC > 0){\n    //then it's BC\n    result = vectorLength(BC);\n  }\n  else if (AB_AC < 0) { \n    //then it's AC\n    result = vectorLength(AC);\n  }\n  else {\n    var div = vectorLength(AB);\n    result = ((AB.x*AC.y) - (AB.y*AC.x))/div;\n    if(result < 0){\n      result *= -1;\n    }\n  }\n  return result;\n}\nfunction updateTracking(worldstate){\n  const DEBUG_TRACKING = false;\n  !DEBUG_TRACKING || console.log(\"Updating tracking!\");\n  //called from act() every tick, updates tracking\n  for (var herokey in worldstate.heroes){//iterates over keys\n    var hero = worldstate.heroes[herokey];\n    !DEBUG_TRACKING || console.log(\"Tracking hero of id:\"+hero.id);\n    if(trackedPositions[hero.id]===undefined){\n      //haven't been tracked before\n      trackedPositions[hero.id]=[];\n    }\n    if(trackedPositions[hero.id].length>0){\n      //teleport detection\n      const MAX_MOVE_PER_TICK = 0.04//normal movement speed is 0.12 per second = 0.002 per tick, that's 20 times that\n      if(vectorLength(vectorDiff(hero.pos,trackedPositions[hero.id][trackedPositions[hero.id].length-1]))>MAX_MOVE_PER_TICK){\n        trackedPositions[hero.id]=[];//drop past tracking for this hero\n        console.log(\"Hero(id:\"+hero.id+\") moved too fast, discarding tracked positions.\")\n      }\n    }\n    trackedPositions[hero.id].push(hero.pos); //add new position to the end\n    while(trackedPositions[hero.id].length > positionTrackingTicks){\n      trackedPositions[hero.id].shift(); //remove first element(oldest pos)\n    }\n    !(worldstate.tick%60==0 && !hero.isBot)|| console.log(FFT(getXValues(trackedPositions[hero.id])));\n  }\n}\nfunction getXValues(arr){\n  //returns an array of arr[i].x\n  let res = [];\n  for(b in arr){\n    res.push(arr[b].x);\n  }\n  return res;\n}\nfunction evadeOverload(worldstate, hero, cooldowns, settings){\n  const DEBUG_EVADE_OVERLOAD = false;\n  let overloadRange = settings.Spells['scourge'].detonate.radius;\n  //!DEBUG_EVADE_OVERLOAD || console.log(\"overload range:\"+overloadRange);\n  // Check if there are players looking to overload you\n  for (key in worldstate.heroes){\n    let enemy = worldstate.heroes[key];\n    if(enemy.id == hero.id||vectorDistance(enemy.pos,hero.pos)<(overloadRange+hero.radius)){\n      continue;//ourselves or too far\n    }\n    if(enemy.casting && enemy.casting.spellId == \"scourge\"){\n      //uh-oh, need to evade right now\n      for(spellId in cooldowns){\n        var meteorSpells = [\"meteorite\",\"meteor\"];\n        if(meteorSpells.indexOf(spellId)>=0 && cooldowns[spellId] === 0){\n          //someone is about to have a bad time...\n          !DEBUG_EVADE_OVERLOAD || console.log(\"Knockbacking overloader!\");\n          return {spellId: spellId, target:enemy.pos};\n        }\n      }\n      var evadeDirection = vectorUnit(vectorDiff(hero.pos, enemy.pos));\n      var step = vectorMultiply(evadeDirection, 2*overloadRange);//the range shouldn't matter much, to be honest\n      var target = vectorPlus(hero.pos, step);\n      !DEBUG_EVADE_OVERLOAD || console.log(\"Evading overload!\");\n      return { spellId: \"move\", target }; \n    }\n  }\n  return null;\n}\n\nfunction act(input) {\n    // Want the bot to do nothing? Uncomment the line below (remove the //):\n    // return null;\n\n    var state = input.state;\n    var heroId = input.heroId;\n    var hero = state.heroes[heroId];\n    var cooldowns = input.cooldowns;\n    var settings = input.settings;\n    var difficulty = input.difficulty;\n    \n    var opponent = findOpponent(state.heroes, heroId);\n    if (!(hero && opponent)) {\n        // Either we're dead, or everyone else is, nothing to do\n        return null;\n    }\n    updateTracking(state);\n    var action = null;\n    if (state.started) {\n        action =\n            evadeOverload(state, hero, cooldowns, settings)\n            ||recovery(state, hero, cooldowns)\n            || dodge(state, hero, cooldowns, settings)\n            || castSpell(state, hero, opponent, cooldowns, settings)\n            || focus(hero, opponent)\n            || chase(state, hero, cooldowns, opponent)\n            || move(state, hero)\n            || face(state, hero, opponent)\n    } else {\n        action =\n            chooseSpells(settings)\n            || dodge(state, hero, cooldowns, settings)\n            || move(state, hero)\n            || face(state, hero, opponent)\n    }\n\n    if (action) {\n        // Give the bot a reaction time otherwise it is OP\n        var reactionMilliseconds = ReactionMillisecondsLookup[action.spellId] || defaultReactionMilliseconds(difficulty);\n        action.delayMilliseconds = reactionMilliseconds;\n        //console.log(action);  \n        return action;\n    } else {\n        return null;\n    }\n}\n\nfunction defaultReactionMilliseconds(difficulty) {\n    var alpha = Math.sqrt(difficulty);\n    return alpha * HardReactionMilliseconds + (1 - alpha) * EasyReactionMilliseconds;\n}\n\nfunction chooseSpells(settings) {\n    if (alreadyChosenSpells) {\n        return null;\n    }\n    alreadyChosenSpells = true;\n\n    var spells = randomSpells(settings);\n  \n    // Want to test a particular spell? Uncomment and edit the lines below\n    /*spells[\"q\"] = \"fireball\";\n    spells[\"w\"] = \"lightning\";\n    spells[\"e\"] = \"forcefield\";\n    spells[\"r\"] = \"repeater\";*/\n    spells[\"q\"] = \"fireball\";\n    spells[\"w\"] = \"boost\";\n    spells[\"e\"] = \"meteorite\";\n    spells[\"r\"] = \"repeater\";\n\n    spells[\"p\"] = \"point\";//used to point at targets\n    return { spells };\n}\n\nfunction randomSpells(settings) {\n\tvar keyBindings = {};\n\tvar allOptions = settings.Choices.Options;\n\tfor (var btn in allOptions) { // One of the buttons, e.g. Q or R\n        var options = allOptions[btn];\n\n        var spellIds = [];\n        for (var i = 0; i < options.length; ++i) {\n            var row = options[i];\n            for (var j = 0; j < row.length; ++j) {\n                var spellId = row[j];\n                spellIds.push(spellId);\n            }\n        }\n\n\t\tif (spellIds.length > 1) {\n\t\t\tkeyBindings[btn] = spellIds[Math.floor(Math.random() * spellIds.length)];\n\t\t}\n\t}\n\treturn keyBindings;\n}\n\nfunction findOpponent(heroes, myHeroId) {\n    var myHero = heroes[myHeroId];\n    if (!myHero) {\n        return null;\n    }\n\n    var choice = null;\n    var closestDist = 1000;\n    for (var heroId in heroes) {\n        var hero = heroes[heroId];\n\n        if (!hero.isEnemy) { continue; }\n\n        // Uncomment the line below to only target humans\n        if (hero.isBot) { continue; }\n        let dist = vectorDistance(hero.pos,myHero.pos);\n        if (dist < closestDist) {\n            // Target the closest enemy instead - SH\n            closestDist = dist;\n            choice = hero;\n        }\n    }\n    return choice;\n}\n\nfunction recovery(state, hero, cooldowns) {\n    if (hero.inside || state.radius <= 0) {\n        // No need to recover\n        return null;\n    }\n\n    var spellId = null;\n    if (cooldowns[\"teleport\"] === 0) {\n        spellId = \"teleport\";\n    } else if (cooldowns[\"thrust\"] === 0) {\n        spellId = \"thrust\";\n    } else if (cooldowns[\"swap\"] === 0) {\n        spellId = \"swap\";\n    } else if (cooldowns[\"voidRush\"] === 0) {\n        spellId = \"voidRush\";\n    } else if (cooldowns[\"vanish\"] === 0) {\n        spellId = \"vanish\";\n    } else {\n        spellId = \"move\";\n    }\n\n    if (spellId) {\n        return { spellId, target: center };\n    }\n    return null;\n}\n\nfunction deflect(state, hero, cooldowns, projectile) {\n    var deflectExcludedProjectiles = [\"boomerang\"];//don't try to deflect annoying spells\n    if(deflectExcludedProjectiles.indexOf(projectile.spellId)>=0){\n     return null;\n    }\n    var target = vectorMidpoint(hero.pos, projectile.pos);\n    var spellId = null;\n    if (cooldowns[\"shield\"] === 0) {\n        spellId = \"shield\";\n    } else if (cooldowns[\"icewall\"] === 0) {\n        spellId = \"icewall\";\n    } else if (cooldowns[\"saber\"] === 0) {\n        spellId = \"saber\";\n    } else if (cooldowns[\"dualSaber\"] === 0) {\n        spellId = \"dualSaber\";\n    } else if (cooldowns[\"meteor\"] === 0) {\n        spellId = \"meteor\";\n    } else if (cooldowns[\"meteorite\"] === 0) {\n        spellId = \"meteorite\";\n    } else if (cooldowns[\"whirlwind\"] === 0) {\n        spellId = \"whirlwind\";\n    } else if (cooldowns[\"phaseOut\"] === 0) {\n        spellId = \"phaseOut\";\n    } else {\n        spellId = null;\n    }\n\n    if (spellId) {\n        return { spellId, target };\n    } else {\n        return null;\n    }\n}\n\nfunction castSpell(state, hero, opponent, cooldowns, settings) {\n    if (!readyForNextSpell(hero)) {\n        return null;\n    }\n\n    var candidates = [];\n    for (var spellId in cooldowns) {\n        if(spellId==\"point\"){\n          continue;//not allowed to use it normally\n        }\n        var readyToCast = !cooldowns[spellId];\n        var spell = settings.Spells[spellId];\n\n        if (spell && readyToCast && validAttack(state, hero, opponent, spell)) {\n            if([\"meteorite\",\"meteor\"].indexOf(spellId) >= 0/* && Math.random() < 0.95*/){\n              continue;//try to not waste those on normal attacks\n            }\n          candidates.push(spellId);\n        }\n    }\n\n    if (candidates.length > 0) {\n        var spellId = candidates[Math.floor(Math.random() * candidates.length)];\n        var action = { spellId, target: aim(opponent, settings.Spells[spellId], hero) };\n        if (action.spellId === spellId) {\n            updateNextSpellTime(spellId);\n        }\n        if(PREDICT_TESTING){\n          action.spellId = \"point\";\n        }\n        return action;\n    } else {\n        return null;\n    }\n}\n\nfunction validAttack(state, hero, opponent, spell) {\n    var opponentShielded = !!opponent.shieldTicksRemaining;\n\n    var distance = vectorDistance(hero.pos, opponent.pos);\n    if (spell.action === \"projectile\" || spell.action === \"spray\" || spell.action === \"retractor\" || spell.action === \"focus\" || spell.action === \"charge\") {\n        if (spell.id === \"swap\") { // Swap doesn't work as an attack\n            return false;\n        }\n        if (opponentShielded && !spell.projectile.detonate) { // Detonate spells can penetrate shields, nothing else can\n            return false;\n        }\n        if (spell.id === \"whip\") {\n            // Just keep casting Electroshock even if out of range\n            return true;\n        }\n\n        var range = spell.projectile.speed * spell.projectile.maxTicks / TicksPerSecond + opponent.radius;\n        return distance <= range;\n    } else if (spell.action === \"scourge\") {\n        var range = spell.radius + opponent.radius;\n        return distance <= range;\n    } else if (spell.id === \"blaze\") {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction readyForNextSpell(hero) {\n    return (\n        Date.now() >= nextSpell // Don't cast too fast\n        || !!hero.link // If linked to something, cast as many spells as possible\n    );\n}\n\nfunction updateNextSpellTime(spellId) {\n    if(spellId == \"repeater\"){\n      //console.log(\"repeater usage detected\")\n      nextSpell = Date.now() + RepeaterCastIntervalMilliseconds;\n      return;\n    }\n    nextSpell = Date.now() + SpellCastIntervalMilliseconds + Math.floor((Math.random() < 0.5 ? -1 : 1) * Math.random() * SpellCastJitterMilliseconds);\n}\n\nfunction jitter(target, missRadius) {\n    var radius = Math.random() * missRadius;\n    var angle = Math.random() * 2 * Math.PI;\n    return {\n        x: target.x + radius * Math.cos(angle),\n        y: target.y + radius * Math.sin(angle),\n    };\n}\n\nfunction focus(hero, opponent) { // When using a spell (e.g. Acolyte Beam, Spirit Missile) - ensure we are focusing the enemy, otherwise we will miss\n    if (hero.casting) {\n        if (hero.casting.spellId === \"blast\" || hero.casting.spellId === \"retractor\" || hero.casting.spellId === \"rocket\") {\n            // Have to release or it won't fire\n            return { spellId: hero.casting.spellId, release: true, target: opponent.pos };\n        } else if (hero.casting.spellId === \"saber\" || hero.casting.spellId === \"dualSaber\") {\n            // Don't focus the lightsaber, just swish it around\n            return { spellId: \"retarget\", target: vectorPlus(hero.pos, vectorFromAngle(hero.heading + Math.PI / 2)) };\n        } else if (hero.casting.spellId === \"grapple\") {\n            // Throw away to the right (TODO: be smarter about this)\n            return { spellId: hero.casting.spellId, release: true, target: vectorPlus(hero.pos, vectorFromAngle(hero.heading + Math.PI / 2)) };\n        } else if (hero.casting.spellId === \"halo\") {\n            return { spellId: \"move\", target: opponent.pos };\n        } else {\n            return { spellId: \"retarget\", target: opponent.pos };\n        }\n    } else {\n        return null;\n    }\n}\n\nfunction chase(state, hero, cooldowns, opponent) {\n    if (\"whip\" in cooldowns) {\n        // Got to get within range when using Electroshock\n        var target = vectorMidpoint(hero.pos, opponent.pos);\n        return { spellId: \"move\", target };\n    } else {\n        return null;\n    }\n}\n\nfunction move(state, hero) {\n    if(DEBUG_NO_MOVE){\n      return null;\n    }\n    let curTick = state.tick;\n    let target;\n    if(curTick < lastMoveTick + movementLocationChangeTicks){\n      target = lastMovePosition;\n    }\n    else{\n      var centroid = { x: 0, y: 0 };\n      var numOpponents = 0;\n      for (var heroId in state.heroes) {\n          if (heroId === hero.id) {\n              continue; // Ignore self\n          }\n  \n          var opponent = state.heroes[heroId];\n          centroid.x += opponent.pos.x;\n          centroid.y += opponent.pos.y;\n  \n          ++numOpponents;\n      }\n      centroid.x /= numOpponents;\n      centroid.y /= numOpponents;\n  \n      if (!numOpponents) {\n          return;\n      }\n  \n      var offset = vectorNegate(vectorDiff(centroid, center)); // Move to the opposite side of the arena\n      var targetDistance = state.radius * 0.33; // Closer to center than edge (for polygonal maps)\n      \n      //randomness! -SH\n      offset = vectorFromAngle(vectorAngle(offset)+2*(Math.random()-0.5)*30*(2*Math.PI/360));\n      targetDistance *= (0.8+0.4*Math.random());\n      target = vectorPlus(center, vectorRelengthen(offset, targetDistance));\n      lastMovePosition = target;\n      lastMoveTick = curTick;\n    }\n    var distanceToTarget = vectorDistance(hero.pos, target);\n    if (distanceToTarget <= 0.01) {\n        // Close enough - don't send any action so the game can sleep while waiting for players\n        return null;\n    }\n\n    return { spellId: \"move\", target };\n}\n\nfunction face(state, hero, opponent) {\n    var target = opponent.pos;\n    var targetAngle = vectorAngle(vectorDiff(opponent.pos, hero.pos));\n    var angleDelta = vectorAngleDelta(hero.heading, targetAngle);\n    if (Math.abs(angleDelta) <= CloseEnoughRadians) {\n        return null;\n    }\n\n    return { spellId: \"retarget\", target };\n}\nfunction closestApproach(curPos,vel,origin){\n  //calculates time and distance of closest approach of projectile to origin (only in future)\n  let toProjectile = vectorDiff(curPos, origin);\n  let radialVel = vectorDot(vel,vectorUnit(toProjectile));\n  if(radialVel>=0){//going away\n    return {time:0,dist:vectorLength(toProjectile),pos:curPos};\n  }\n  let normal = vectorUnit({x:vel.y,y:-vel.x});//normal vector to projectile's path\n  if(vectorDot(normal,toProjectile)<0){//we'll take the normal pointing mostly from origin to projectile\n    normal = vectorMultiply(normal,-1);\n  }\n  let distance = vectorDot(toProjectile,normal);//the component of radius-vector that's normal to velocity IS the closest approach\n  \n  let approachPos = vectorPlus(origin,vectorMultiply(normal,distance));\n  let timeToApproach = vectorLength(vectorDiff(approachPos,curPos))/vectorLength(vel);//these vectors should be parallel, so just divide lengths\n  return {time:timeToApproach,dist:distance,pos:approachPos};\n}\nfunction dodge(state, hero, cooldowns, settings) {\n    var DEBUG_DODGE = false;\n    var resultAction = null;\n    var timeToAction = 100000; //the lower, the more urgent dodging this projectile is.\n    for (var projectileId in state.projectiles) {\n        var projectile = state.projectiles[projectileId];\n        if (projectile.ownerId === hero.id) {\n            // This is my own projectile\n            continue;\n        }\n\n        if (projectile.spellId === \"halo\") {\n            // Halo is never coming for us, it orbits around its owner\n            continue;\n        }\n        \n        let effectiveRadius = settings.Spells[projectile.spellId].projectile.detonate?(Math.max(projectile.radius,settings.Spells[projectile.spellId].projectile.detonate.radius)):(projectile.radius);\n        let effectiveDodgeDistance = Math.max(minDodgeDistance, effectiveRadius + hero.radius + minDodgeDistance/2);\n        if(settings.Spells[projectile.spellId].projectile.detonate){\n          effectiveDodgeDistance += minDodgeDistance/2;//AoE spells need more care\n        }\n        !DEBUG_DODGE || !settings.Spells[projectile.spellId].projectile.detonate ||console.log(\"Projectile has AOE; using bigger effectiveDodgeDistance:\"+effectiveDodgeDistance);\n        var diff = vectorDiff(hero.pos, projectile.pos);\n        var distancePerTimeStep = vectorDot(projectile.velocity, vectorUnit(diff));//this is -radial velocity\n        if (distancePerTimeStep <= 0) {\n            // Not coming towards us\n            continue;\n        }\n        var approachCalc = closestApproach(projectile.pos,projectile.velocity,hero.pos);\n        //!DEBUG_DODGE || console.log(approachCalc);\n        if (approachCalc.dist >= effectiveDodgeDistance|| approachCalc.time >= minDodgeTime) {\n            // Will pass too far away or can wait.\n            //!DEBUG_DODGE || console.log(\"Ignoring potential threat:\"+projectile.spellId);\n            continue;\n        }\n        if(approachCalc.dist <= (hero.radius + effectiveRadius)*1.1 && approachCalc.time < maxDeflectTime){\n          //going to hit us - try to deflect. TODO: be smarter, sometimes it's better to take the hit\n          var deflectAction = deflect(state, hero, cooldowns, projectile);\n          !(deflectAction||state.tick%5==0)|| !DEBUG_DODGE || console.log(\"Trying to deflect:\"+projectile.spellId);\n          if (deflectAction) {\n              resultAction = deflectAction;\n              timeToAction = 0;\n          }\n        }\n        \n\n        // Run away from collision point\n        if(approachCalc.time < timeToAction){\n          !(state.tick%5==0)||!DEBUG_DODGE || console.log(\"Trying to dodge:\"+projectile.spellId);\n          var direction = vectorUnit(vectorDiff(hero.pos, approachCalc.pos));\n          var step = vectorMultiply(direction, minDodgeDistance);\n          var target = vectorPlus(hero.pos, step);\n          resultAction = { spellId: \"move\", target };\n          timeToAction = approachCalc.time;\n        }\n    }\n    return resultAction;\n}\n\nfunction vectorDiff(to, from) {\n    return { x: to.x - from.x, y: to.y - from.y };\n}\n\nfunction vectorLength(vector) {\n    return Math.sqrt(vector.x * vector.x + vector.y * vector.y);\n}\n\nfunction vectorDistance(from, to) {\n    return vectorLength(vectorDiff(from, to));\n}\n\nfunction vectorUnit(vec) {\n    var length = vectorLength(vec);\n    return length === 0 ? vec : vectorMultiply(vec, 1 / length);\n}\n\nfunction vectorPlus(from, offset) {\n    return { x: from.x + offset.x, y: from.y + offset.y };\n}\n\nfunction vectorMultiply(vec, multiplier) {\n    return { x: vec.x * multiplier, y: vec.y * multiplier };\n}\n\nfunction vectorRelengthen(vec, length) {\n    return vectorMultiply(vectorUnit(vec), length);\n}\n\nfunction vectorNegate(vec) {\n    return vectorMultiply(vec, -1);\n}\n\nfunction vectorDot(a, b) {\n    return (a.x * b.x) + (a.y * b.y);\n}\n\nfunction vectorMidpoint(a, b) {\n    var diff = vectorDiff(b, a);\n    return vectorPlus(a, vectorMultiply(diff, 0.5));\n}\n\nfunction vectorFromAngle(angle) {\n\treturn { x: Math.cos(angle), y: Math.sin(angle) };\n}\n\nfunction vectorAngle(vec) {\n    return Math.atan2(vec.y, vec.x);\n}\n\nfunction vectorAngleDelta(currentAngle, targetAngle) {\n\tvar delta = targetAngle - currentAngle;\n\twhile (delta > Math.PI) {\n\t\tdelta -= 2 * Math.PI;\n\t}\n\twhile (delta < -Math.PI) {\n\t\tdelta += 2 * Math.PI;\n\t}\n\treturn delta;\n}\n\n\n\nclass baseComplexArray {\n  constructor(other, arrayType = Float32Array) {\n    if (other instanceof baseComplexArray) {\n      // Copy constuctor.\n      this.ArrayType = other.ArrayType;\n      this.real = new this.ArrayType(other.real);\n      this.imag = new this.ArrayType(other.imag);\n    } else {\n      this.ArrayType = arrayType;\n      // other can be either an array or a number.\n      this.real = new this.ArrayType(other);\n      this.imag = new this.ArrayType(this.real.length);\n    }\n\n    this.length = this.real.length;\n  }\n\n  toString() {\n    const components = [];\n\n    this.forEach((value, i) => {\n      components.push(\n        `(${value.real.toFixed(2)}, ${value.imag.toFixed(2)})`\n      );\n    });\n\n    return `[${components.join(', ')}]`;\n  }\n\n  forEach(iterator) {\n    const n = this.length;\n    // For gc efficiency, re-use a single object in the iterator.\n    const value = Object.seal(Object.defineProperties({}, {\n      real: {writable: true}, imag: {writable: true},\n    }));\n\n    for (let i = 0; i < n; i++) {\n      value.real = this.real[i];\n      value.imag = this.imag[i];\n      iterator(value, i, n);\n    }\n  }\n\n  // In-place mapper.\n  map(mapper) {\n    this.forEach((value, i, n) => {\n      mapper(value, i, n);\n      this.real[i] = value.real;\n      this.imag[i] = value.imag;\n    });\n\n    return this;\n  }\n\n  conjugate() {\n    return new baseComplexArray(this).map((value) => {\n      value.imag *= -1;\n    });\n  }\n\n  magnitude() {\n    const mags = new this.ArrayType(this.length);\n\n    this.forEach((value, i) => {\n      mags[i] = Math.sqrt(value.real*value.real + value.imag*value.imag);\n    })\n\n    return mags;\n  }\n}\n\n//fft.js\n// Math constants and functions we need.\nconst PI = Math.PI;\nconst SQRT1_2 = Math.SQRT1_2;\n\nfunction FFT(input) {\n  return ensureComplexArray(input).FFT();\n};\n\nfunction InvFFT(input) {\n  return ensureComplexArray(input).InvFFT();\n};\n\nfunction frequencyMap(input, filterer) {\n  return ensureComplexArray(input).frequencyMap(filterer);\n};\n\nclass ComplexArray extends baseComplexArray {\n  FFT() {\n    return fft(this, false);\n  }\n\n  InvFFT() {\n    return fft(this, true);\n  }\n\n  // Applies a frequency-space filter to input, and returns the real-space\n  // filtered input.\n  // filterer accepts freq, i, n and modifies freq.real and freq.imag.\n  frequencyMap(filterer) {\n    return this.FFT().map(filterer).InvFFT();\n  }\n}\n\nfunction ensureComplexArray(input) {\n  return input instanceof baseComplexArray && input || new ComplexArray(input);\n}\n\nfunction fft(input, inverse) {\n  const n = input.length;\n\n  if (n & (n - 1)) {\n    return FFT_Recursive(input, inverse);\n  } else {\n    return FFT_2_Iterative(input, inverse);\n  }\n}\n\nfunction FFT_Recursive(input, inverse) {\n  const n = input.length;\n\n  if (n === 1) {\n    return input;\n  }\n\n  const output = new ComplexArray(n, input.ArrayType);\n\n  // Use the lowest odd factor, so we are able to use FFT_2_Iterative in the\n  // recursive transforms optimally.\n  const p = LowestOddFactor(n);\n  const m = n / p;\n  const normalisation = 1 / Math.sqrt(p);\n  let recursive_result = new ComplexArray(m, input.ArrayType);\n\n  // Loops go like O(n Î£ p_i), where p_i are the prime factors of n.\n  // for a power of a prime, p, this reduces to O(n p log_p n)\n  for(let j = 0; j < p; j++) {\n    for(let i = 0; i < m; i++) {\n      recursive_result.real[i] = input.real[i * p + j];\n      recursive_result.imag[i] = input.imag[i * p + j];\n    }\n    // Don't go deeper unless necessary to save allocs.\n    if (m > 1) {\n      recursive_result = fft(recursive_result, inverse);\n    }\n\n    const del_f_r = Math.cos(2*PI*j/n);\n    const del_f_i = (inverse ? -1 : 1) * Math.sin(2*PI*j/n);\n    let f_r = 1;\n    let f_i = 0;\n\n    for(let i = 0; i < n; i++) {\n      const _real = recursive_result.real[i % m];\n      const _imag = recursive_result.imag[i % m];\n\n      output.real[i] += f_r * _real - f_i * _imag;\n      output.imag[i] += f_r * _imag + f_i * _real;\n\n      [f_r, f_i] = [\n        f_r * del_f_r - f_i * del_f_i,\n        f_i = f_r * del_f_i + f_i * del_f_r,\n      ];\n    }\n  }\n\n  // Copy back to input to match FFT_2_Iterative in-placeness\n  // TODO: faster way of making this in-place?\n  for(let i = 0; i < n; i++) {\n    input.real[i] = normalisation * output.real[i];\n    input.imag[i] = normalisation * output.imag[i];\n  }\n\n  return input;\n}\n\nfunction FFT_2_Iterative(input, inverse) {\n  const n = input.length;\n\n  const output = BitReverseComplexArray(input);\n  const output_r = output.real;\n  const output_i = output.imag;\n  // Loops go like O(n log n):\n  //   width ~ log n; i,j ~ n\n  let width = 1;\n  while (width < n) {\n    const del_f_r = Math.cos(PI/width);\n    const del_f_i = (inverse ? -1 : 1) * Math.sin(PI/width);\n    for (let i = 0; i < n/(2*width); i++) {\n      let f_r = 1;\n      let f_i = 0;\n      for (let j = 0; j < width; j++) {\n        const l_index = 2*i*width + j;\n        const r_index = l_index + width;\n\n        const left_r = output_r[l_index];\n        const left_i = output_i[l_index];\n        const right_r = f_r * output_r[r_index] - f_i * output_i[r_index];\n        const right_i = f_i * output_r[r_index] + f_r * output_i[r_index];\n\n        output_r[l_index] = SQRT1_2 * (left_r + right_r);\n        output_i[l_index] = SQRT1_2 * (left_i + right_i);\n        output_r[r_index] = SQRT1_2 * (left_r - right_r);\n        output_i[r_index] = SQRT1_2 * (left_i - right_i);\n\n        [f_r, f_i] = [\n          f_r * del_f_r - f_i * del_f_i,\n          f_r * del_f_i + f_i * del_f_r,\n        ];\n      }\n    }\n    width <<= 1;\n  }\n\n  return output;\n}\n\nfunction BitReverseIndex(index, n) {\n  let bitreversed_index = 0;\n\n  while (n > 1) {\n    bitreversed_index <<= 1;\n    bitreversed_index += index & 1;\n    index >>= 1;\n    n >>= 1;\n  }\n  return bitreversed_index;\n}\n\nfunction BitReverseComplexArray(array) {\n  const n = array.length;\n  const flips = new Set();\n\n  for(let i = 0; i < n; i++) {\n    const r_i = BitReverseIndex(i, n);\n\n    if (flips.has(i)) continue;\n\n    [array.real[i], array.real[r_i]] = [array.real[r_i], array.real[i]];\n    [array.imag[i], array.imag[r_i]] = [array.imag[r_i], array.imag[i]];\n\n    flips.add(r_i);\n  }\n\n  return array;\n}\n\nfunction LowestOddFactor(n) {\n  const sqrt_n = Math.sqrt(n);\n  let factor = 3;\n\n  while(factor <= sqrt_n) {\n    if (n % factor === 0) return factor;\n    factor += 2;\n  }\n  return n;\n}\n\n// See ai.contracts.ts: Must return a BotContract\nreturn { act };"
}